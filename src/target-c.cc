#include "target-c.h"

#include "util.h"

#include <algorithm>
#include <iterator>

namespace target::c {
namespace {

constexpr char kHeader[] = R"(
// Generated by the gel compiler.
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

void gel_print(int_least64_t number) { printf("%d\n", number); }

// Start of user code.
)";

constexpr char kFooter[] = R"(
// End of user code.

int main() { return gel_main(); }
)";

class Type : public ast::TypeVisitor {
 public:
  Type(std::ostream& output) : output_(output) {}

  void Visit(const ast::Void&) override;
  void Visit(const ast::Primitive&) override;
  void Visit(const ast::Function&) override;

 private:
  std::ostream& output_;
};

class Expression : public ast::ExpressionVisitor {
 public:
  Expression(std::ostream& output) : output_(output) {}

  using ExpressionVisitor::Visit;
  void Visit(const ast::Identifier&) override;
  void Visit(const ast::Boolean&) override;
  void Visit(const ast::Integer&) override;
  void Visit(const ast::Binary&) override;
  void Visit(const ast::FunctionCall&) override;
  void Visit(const ast::LogicalNot&) override;

 private:
  std::ostream& output_;
};

class Statement : public ast::StatementVisitor {
 public:
  Statement(std::ostream& output, int indent)
      : output_(output), indent_(indent) {}

  using StatementVisitor::Visit;
  void Visit(const ast::DefineVariable&) override;
  void Visit(const ast::Assign&) override;
  void Visit(const ast::DoFunction&) override;
  void Visit(const ast::If&) override;
  void Visit(const ast::While&) override;
  void Visit(const ast::ReturnVoid&) override;
  void Visit(const ast::Return&) override;
  void Visit(const std::vector<ast::Statement>& statements);

 private:
  std::ostream& output_;
  int indent_;
};

class TopLevel : public ast::TopLevelVisitor {
 public:
  TopLevel(std::ostream& output);

  using TopLevelVisitor::Visit;
  void Visit(const ast::DefineFunction&) override;
  void Visit(const std::vector<ast::DefineFunction>&) override;

 private:
  std::ostream& output_;
};

void Type::Visit(const ast::Void&) {
  output_ << "void";
}

void Type::Visit(const ast::Primitive& primitive) {
  switch (primitive) {
    case ast::Primitive::BOOLEAN: output_ << "bool"; break;
    case ast::Primitive::INTEGER: output_ << "int_least64_t"; break;
  }
}

void Type::Visit(const ast::Function&) {
  throw std::logic_error(
      "No function types should have to be visited when compiling.");
}

void Expression::Visit(const ast::Identifier& identifier) {
  output_ << "gel_" << identifier.name;
}

void Expression::Visit(const ast::Boolean& boolean) {
  output_ << (boolean.value ? "true" : "false");
}

void Expression::Visit(const ast::Integer& integer) {
  output_ << integer.value;
}

void Expression::Visit(const ast::Binary& binary) {
  output_ << "(";
  Visit(binary.left);
  output_ << " ";
  switch (binary.operation) {
    case ast::Binary::ADD: output_ << "+"; break;
    case ast::Binary::COMPARE_EQ: output_ << "=="; break;
    case ast::Binary::COMPARE_GE: output_ << ">="; break;
    case ast::Binary::COMPARE_GT: output_ << ">"; break;
    case ast::Binary::COMPARE_LE: output_ << "<="; break;
    case ast::Binary::COMPARE_LT: output_ << "<"; break;
    case ast::Binary::COMPARE_NE: output_ << "!="; break;
    case ast::Binary::DIVIDE: output_ << "/"; break;
    case ast::Binary::LOGICAL_AND: output_ << "&&"; break;
    case ast::Binary::LOGICAL_OR: output_ << "||"; break;
    case ast::Binary::MULTIPLY: output_ << "*"; break;
    case ast::Binary::SUBTRACT: output_ << "-"; break;
  }
  output_ << " ";
  Visit(binary.right);
  output_ << ")";
}

void Expression::Visit(const ast::FunctionCall& call) {
  Visit(call.function);
  output_ << "(";
  bool first = true;
  for (const auto& argument : call.arguments) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Visit(argument);
  }
  output_ << ")";
}

void Expression::Visit(const ast::LogicalNot& op) {
  output_ << "!";
  Visit(op.argument);
}

void Statement::Visit(const ast::DefineVariable& definition) {
  output_ << util::Spaces{indent_};
  Type type_codegen{output_};
  definition.variable.type.value().Visit(type_codegen);
  output_ << " ";
  Expression name_codegen{output_};
  name_codegen.Visit(definition.variable);
  output_ << " = ";
  Expression codegen{output_};
  codegen.Visit(definition.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::Assign& assignment) {
  output_ << util::Spaces{indent_};
  Expression name_codegen{output_};
  name_codegen.Visit(assignment.variable);
  output_ << " = ";
  Expression codegen{output_};
  codegen.Visit(assignment.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::DoFunction& do_function) {
  output_ << util::Spaces{indent_};
  Expression codegen{output_};
  codegen.Visit(do_function.function_call);
  output_ << ";\n";
}

void Statement::Visit(const ast::If& if_statement) {
  output_ << util::Spaces{indent_} << "if (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(if_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(if_statement.if_true);
  output_ << util::Spaces{indent_} << "} else {\n";
  codegen.Visit(if_statement.if_false);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::While& while_statement) {
  output_ << util::Spaces{indent_} << "while (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(while_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(while_statement.body);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::ReturnVoid&) {
  output_ << util::Spaces{indent_} << "return;\n";
}

void Statement::Visit(const ast::Return& return_statement) {
  output_ << util::Spaces{indent_} << "return ";
  Expression codegen{output_};
  codegen.Visit(return_statement.value);
  output_ << ";\n";
}

void Statement::Visit(const std::vector<ast::Statement>& statements) {
  for (const auto& statement : statements) Visit(statement);
}

TopLevel::TopLevel(std::ostream& output) : output_(output) {}

void TopLevel::Visit(const ast::DefineFunction& definition) {
  Type return_type_codegen{output_};
  const ast::Function* type =
      ast::GetFunctionType(definition.function.type.value());
  type->return_type.Visit(return_type_codegen);
  output_ << " ";
  Expression name_codegen{output_};
  name_codegen.Visit(definition.function);
  output_ << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Type type_codegen{output_};
    parameter.type.value().Visit(type_codegen);
    output_ << " ";
    Expression name_codegen{output_};
    name_codegen.Visit(parameter);
  }
  output_ << ") {\n";
  Statement codegen{output_, 2};
  codegen.Visit(definition.body);
  output_ << "}\n";
}

void TopLevel::Visit(const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      output_ << "\n";
    }
    Visit(definition);
  }
}

}  // namespace

void Compile(const ast::TopLevel& top_level, std::ostream* output) {
  *output << kHeader;
  TopLevel codegen{*output};
  top_level.Visit(codegen);
  *output << kFooter;
}

}  // namespace target::c
