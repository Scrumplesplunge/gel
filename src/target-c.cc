#include "target-c.h"

#include "types.h"
#include "util.h"

#include <algorithm>
#include <iterator>
#include <map>

namespace target::c {
namespace {

using std::literals::operator""sv;

constexpr char kHeader[] = R"(
// Generated by the gel compiler.
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// gel_void is an actual value type to simplify code generation.
typedef struct gel_void {} gel_void;

typedef bool gel_boolean;
typedef int_least64_t gel_integer;

static inline gel_void gel_print(gel_integer number) {
  printf("%lld\n", (long long) number);
}

static inline gel_void gelcopy_gel_void(gel_void source) { return source; }

static inline gel_boolean gelcopy_gel_boolean(gel_boolean source) {
  return source;
}

static inline gel_integer gelcopy_gel_integer(gel_integer source) {
  return source;
}

static inline void geldestroy_gel_void(gel_void unused) {}
static inline void geldestroy_gel_boolean(gel_boolean unused) {}
static inline void geldestroy_gel_integer(gel_integer unused) {}

// Start of user code.
)";

constexpr char kFooter[] = R"(
// End of user code.

int main() { return gel_main(); }
)";

class Compiler {
 public:
  Compiler(std::ostream* output) : output_(output) {}

  // Emit code to declare the given type.
  void DeclareType(const types::Void&);
  void DeclareType(const types::Function&);
  void DeclareType(const types::Primitive&);
  void DeclareType(const types::Array&);
  void DeclareAnyType(const types::Type&);

  // Emit an assignment of the given expression to the given output variable.
  // The variable is not declared as part of this, so it should have already
  // been declared. The current line and any additional lines should be indented
  // by the given indent amount. The output should be terminated with a newline.
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Identifier&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Boolean&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Integer&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::ArrayLiteral&,
                         int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Arithmetic&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Compare&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::Logical&, int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::FunctionCall&,
                         int indent);
  void CompileExpression(std::string_view output,
                         const analysis::AnnotatedAst::LogicalNot&, int indent);
  void CompileAnyExpression(std::string_view output,
                            const analysis::AnnotatedAst::Expression&,
                            int indent);

  // Emit code to execute the given statement. The current line and any
  // additional lines should be indented by the given indent amount. The output
  // should be terminated with a newline.
  void CompileStatement(const analysis::AnnotatedAst::DefineVariable&,
                        int indent);
  void CompileStatement(const analysis::AnnotatedAst::Assign&, int indent);
  void CompileStatement(const analysis::AnnotatedAst::DoFunction&, int indent);
  void CompileStatement(const analysis::AnnotatedAst::If&, int indent);
  void CompileStatement(const analysis::AnnotatedAst::While&, int indent);
  void CompileStatement(const analysis::AnnotatedAst::ReturnVoid&, int indent);
  void CompileStatement(const analysis::AnnotatedAst::Return&, int indent);
  void CompileStatement(const std::vector<analysis::AnnotatedAst::Statement>&,
                        int indent);
  void CompileAnyStatement(const analysis::AnnotatedAst::Statement&,
                           int indent);

  // Emit code to declare the given constructs.
  void CompileTopLevel(const analysis::AnnotatedAst::DefineFunction&);
  void CompileTopLevel(
      const std::vector<analysis::AnnotatedAst::DefineFunction>&);
  void CompileAnyTopLevel(const analysis::AnnotatedAst::TopLevel&);

 private:
  // Generate a new unique identifier.
  std::string NextIdentifier();

  std::ostream* output_;
  std::uint64_t next_id_ = 0;
  std::map<types::Type, std::string> type_names_ = {
      {types::Void{}, "gel_void"},
      {types::Primitive::BOOLEAN, "gel_boolean"},
      {types::Primitive::INTEGER, "gel_integer"},
  };
};

void Compiler::DeclareType(const types::Void&) {
  *output_ << "// <nothing to declare>\n";
}

void Compiler::DeclareType(const types::Function&) {
  *output_ << "// <nothing to declare>\n";
}

void Compiler::DeclareType(const types::Primitive&) {
  *output_ << "// <nothing to declare>\n";
}

constexpr char kDeclaration[] = R"(
typedef struct ${TYPE} {
  ${ELEMENT_TYPE}* data;
  gel_integer size;
} ${TYPE};

static ${TYPE} gelcopy_${TYPE}(${TYPE} source) {
  ${ELEMENT_TYPE}* data = malloc(source.size * sizeof(${ELEMENT_TYPE}));
  for (gel_integer i = 0; i < source.size; i++) {
    data[i] = gelcopy_${ELEMENT_TYPE}(source.data[i]);
  }
  return (struct ${TYPE}) {
    .data = data,
    .size = source.size,
  };
}

static void geldestroy_${TYPE}(${TYPE} source) {
  for (gel_integer i = source.size - 1; i >= 0; i--) {
    geldestroy_${ELEMENT_TYPE}(source.data[i]);
  }
  free(source.data);
}
)";
void Compiler::DeclareType(const types::Array& array) {
  auto name = NextIdentifier();
  const auto& element_name = type_names_.at(array.element_type);
  util::substitute(*output_, kDeclaration,
                   {
                       {"TYPE"sv, name},
                       {"ELEMENT_TYPE"sv, element_name},
                   });
  type_names_.emplace(array, name);
}

void Compiler::DeclareAnyType(const types::Type& type) {
  *output_ << "// " << type << "\n";
  type.visit([this](auto x) { DeclareType(x); });
}

void Compiler::CompileExpression(
    std::string_view variable,
    const analysis::AnnotatedAst::Identifier& identifier, int indent) {
  const auto& type_name = type_names_.at(identifier.type);
  *output_ << util::Spaces{indent} << variable << " = gelcopy_" << type_name
           << "(gel_" << identifier.name << ");\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const analysis::AnnotatedAst::Boolean& boolean,
                                 int indent) {
  *output_ << util::Spaces{indent} << variable << " = "
           << (boolean.value ? "true" : "false") << ";\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const analysis::AnnotatedAst::Integer& integer,
                                 int indent) {
  *output_ << util::Spaces{indent} << variable << " = " << integer.value
           << ";\n";
}

void Compiler::CompileExpression(
    std::string_view variable,
    const analysis::AnnotatedAst::ArrayLiteral& array, int indent) {
  const types::Type& element_type =
      array.type.get_if<types::Array>()->element_type;
  const auto& element_type_name = type_names_.at(element_type);
  auto temp = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << element_type_name << "* " << temp
           << " = malloc(" << array.parts.size() << " * sizeof("
           << element_type_name << "));\n";
  for (std::size_t i = 0, n = array.parts.size(); i < n; i++) {
    CompileAnyExpression(temp + "[" + std::to_string(i) + "]", array.parts[i],
                         indent + 2);
  }
  const auto& array_type_name = type_names_.at(array.type);
  *output_ << util::Spaces{indent + 2} << variable << " = (struct "
           << array_type_name << ") {\n"
           << util::Spaces{indent + 4} << ".data = " << temp << ",\n"
           << util::Spaces{indent + 4} << ".size = " << array.parts.size()
           << ",\n"
           << util::Spaces{indent + 2} << "};\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(
    std::string_view variable, const analysis::AnnotatedAst::Arithmetic& binary,
    int indent) {
  const auto& type_name = type_names_.at(binary.type);
  auto left = NextIdentifier(), right = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << type_name << " " << left << ", "
           << right << ";\n";
  CompileAnyExpression(left, binary.left, indent + 2);
  CompileAnyExpression(right, binary.right, indent + 2);
  *output_ << util::Spaces{indent + 2} << variable << " = " << left << " ";
  switch (binary.operation) {
    case ast::Arithmetic::ADD:
      *output_ << "+";
      break;
    case ast::Arithmetic::DIVIDE:
      *output_ << "/";
      break;
    case ast::Arithmetic::MULTIPLY:
      *output_ << "*";
      break;
    case ast::Arithmetic::SUBTRACT:
      *output_ << "-";
      break;
  }
  *output_ << " " << right << ";\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const analysis::AnnotatedAst::Compare& binary,
                                 int indent) {
  const auto& type_name =
      type_names_.at(analysis::AnnotatedAst::GetMeta(binary.left).type);
  auto left = NextIdentifier(), right = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << type_name << " " << left << ", "
           << right << ";\n";
  CompileAnyExpression(left, binary.left, indent + 2);
  CompileAnyExpression(right, binary.right, indent + 2);
  *output_ << util::Spaces{indent + 2} << variable << " = " << left << " ";
  switch (binary.operation) {
    case ast::Compare::EQUAL:
      *output_ << "==";
      break;
    case ast::Compare::GREATER_OR_EQUAL:
      *output_ << ">=";
      break;
    case ast::Compare::GREATER_THAN:
      *output_ << ">";
      break;
    case ast::Compare::LESS_OR_EQUAL:
      *output_ << "<=";
      break;
    case ast::Compare::LESS_THAN:
      *output_ << "<";
      break;
    case ast::Compare::NOT_EQUAL:
      *output_ << "!=";
      break;
  }
  *output_ << " " << right << ";\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const analysis::AnnotatedAst::Logical& binary,
                                 int indent) {
  auto end = NextIdentifier();
  CompileAnyExpression(variable, binary.left, indent);
  // Generate the short-circuit path.
  *output_ << util::Spaces{indent} << "if (";
  switch (binary.operation) {
    case ast::Logical::AND:
      *output_ << "!" << variable;
      break;
    case ast::Logical::OR:
      *output_ << variable;
      break;
  }
  *output_ << ") goto " << end << ";\n";
  CompileAnyExpression(variable, binary.right, indent);
  *output_ << end << ":\n";
}

void Compiler::CompileExpression(
    std::string_view variable, const analysis::AnnotatedAst::FunctionCall& call,
    int indent) {
  *output_ << util::Spaces{indent} << "{\n";
  // Generate each argument, left-to-right, and store them in variables.
  auto n = call.arguments.size();
  std::vector<std::string> arguments;
  arguments.reserve(n);
  for (std::size_t i = 0; i < n; i++) {
    arguments.push_back(NextIdentifier());
    const auto& type_name =
        type_names_.at(analysis::AnnotatedAst::GetMeta(call.arguments[i]).type);
    *output_ << util::Spaces{indent + 2} << type_name << " " << arguments.back()
             << ";\n";
    CompileAnyExpression(arguments.back(), call.arguments[i], indent + 2);
  }

  // Call the function with all of the arguments.
  *output_ << util::Spaces{indent} << variable << " = gel_" << call.function
           << "(";
  bool first = true;
  for (const auto& argument : arguments) {
    if (first) {
      first = false;
    } else {
      *output_ << ", ";
    }
    *output_ << argument;
  }
  *output_ << ");\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const analysis::AnnotatedAst::LogicalNot& op,
                                 int indent) {
  CompileAnyExpression(variable, op.argument, indent);
  *output_ << util::Spaces{indent} << variable << " = !" << variable << ";\n";
}

void Compiler::CompileAnyExpression(
    std::string_view variable,
    const analysis::AnnotatedAst::Expression& expression, int indent) {
  expression.visit(
      [&](const auto& node) { CompileExpression(variable, node, indent); });
}

void Compiler::CompileStatement(
    const analysis::AnnotatedAst::DefineVariable& definition, int indent) {
  const auto& type_name = type_names_.at(definition.variable.type);
  *output_ << util::Spaces{indent} << type_name << " gel_"
           << definition.variable.name << ";\n";
  CompileAnyExpression("gel_" + definition.variable.name, definition.value,
                       indent);
}

void Compiler::CompileStatement(
    const analysis::AnnotatedAst::Assign& assignment, int indent) {
  CompileAnyExpression("gel_" + assignment.variable.name, assignment.value,
                       indent);
}

void Compiler::CompileStatement(
    const analysis::AnnotatedAst::DoFunction& do_function, int indent) {
  auto ignored_result = NextIdentifier();
  const auto& result_type_name = type_names_.at(do_function.function_call.type);
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << result_type_name << " "
           << ignored_result << ";\n";
  CompileExpression(ignored_result, do_function.function_call, indent + 2);
  *output_ << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const analysis::AnnotatedAst::If& if_statement,
                                int indent) {
  auto condition = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << "bool " << condition << ";\n";
  CompileAnyExpression(condition, if_statement.condition, indent + 2);
  *output_ << util::Spaces{indent + 2} << "if (" << condition << ") {\n";
  CompileStatement(if_statement.if_true, indent + 4);
  *output_ << util::Spaces{indent + 2} << "} else {\n";
  CompileStatement(if_statement.if_false, indent + 4);
  *output_ << util::Spaces{indent + 2} << "}\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(
    const analysis::AnnotatedAst::While& while_statement, int indent) {
  auto condition = NextIdentifier();
  *output_ << util::Spaces{indent} << "while (true) {\n"
           << util::Spaces{indent + 2} << "bool " << condition << ";\n";
  CompileAnyExpression(condition, while_statement.condition, indent + 2);
  *output_ << util::Spaces{indent + 2} << "if (!" << condition << ") break;\n";
  CompileStatement(while_statement.body, indent + 2);
  *output_ << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const analysis::AnnotatedAst::ReturnVoid&,
                                int indent) {
  *output_ << util::Spaces{indent} << "return;\n";
}

void Compiler::CompileStatement(
    const analysis::AnnotatedAst::Return& return_statement, int indent) {
  auto result = NextIdentifier();
  const auto& result_type_name = type_names_.at(
      analysis::AnnotatedAst::GetMeta(return_statement.value).type);
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << result_type_name << " " << result
           << ";\n";
  CompileAnyExpression(result, return_statement.value, indent + 2);
  *output_ << util::Spaces{indent + 2} << "return " << result << ";\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(
    const std::vector<analysis::AnnotatedAst::Statement>& statements,
    int indent) {
  for (const auto& statement : statements)
    CompileAnyStatement(statement, indent);
}

void Compiler::CompileAnyStatement(
    const analysis::AnnotatedAst::Statement& statement, int indent) {
  statement.visit([&](const auto& x) { CompileStatement(x, indent); });
}

void Compiler::CompileTopLevel(
    const analysis::AnnotatedAst::DefineFunction& definition) {
  const auto& return_type_name = type_names_.at(definition.type.return_type);
  *output_ << "static " << return_type_name << " gel_" << definition.name
           << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      *output_ << ", ";
    }
    const auto& parameter_type_name = type_names_.at(parameter.type);
    *output_ << parameter_type_name << " gel_" << parameter.name;
  }
  *output_ << ") {\n";
  CompileStatement(definition.body, 2);
  *output_ << "}\n";
}

void Compiler::CompileTopLevel(
    const std::vector<analysis::AnnotatedAst::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      *output_ << "\n";
    }
    CompileTopLevel(definition);
  }
}

void Compiler::CompileAnyTopLevel(
    const analysis::AnnotatedAst::TopLevel& top_level) {
  top_level.visit([&](const auto& x) { CompileTopLevel(x); });
}

std::string Compiler::NextIdentifier() {
  auto id = next_id_++;
  return "gel" + std::to_string(id);
}

}  // namespace

void Compile(const std::vector<types::Type>& types,
             const analysis::AnnotatedAst::TopLevel& top_level,
             std::ostream* output) {
  Compiler compiler{output};
  *output << kHeader;
  for (const auto& type : types) compiler.DeclareAnyType(type);
  compiler.CompileAnyTopLevel(top_level);
  *output << kFooter;
}

}  // namespace target::c
