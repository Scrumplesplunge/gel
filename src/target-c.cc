#include "target-c.h"

#include <algorithm>
#include <iterator>

namespace target::c {
namespace {

struct indent_by { int amount; };

std::ostream& operator<<(std::ostream& output, indent_by indent) {
  std::fill_n(std::ostream_iterator<char>{output}, indent.amount, ' ');
  return output;
}

constexpr char kPrelude[] = R"(
// Generated by the gel compiler.
#include <stdio.h>

void print(int number) { printf("%d\n", number); }

// Start of user code.
)";

}  // namespace

void Expression::Visit(const ast::Identifier& identifier) {
  output_ << identifier.name;
}

void Expression::Visit(const ast::Integer& integer) {
  output_ << integer.value;
}

void Expression::Visit(const ast::Binary& binary) {
  output_ << "(";
  Visit(binary.left);
  output_ << " ";
  switch (binary.operation) {
    case ast::Binary::ADD: output_ << "+"; break;
    case ast::Binary::COMPARE_EQ: output_ << "=="; break;
    case ast::Binary::COMPARE_GE: output_ << ">="; break;
    case ast::Binary::COMPARE_GT: output_ << ">"; break;
    case ast::Binary::COMPARE_LE: output_ << "<="; break;
    case ast::Binary::COMPARE_LT: output_ << "<"; break;
    case ast::Binary::COMPARE_NE: output_ << "!="; break;
    case ast::Binary::DIVIDE: output_ << "/"; break;
    case ast::Binary::LOGICAL_AND: output_ << "&&"; break;
    case ast::Binary::LOGICAL_OR: output_ << "||"; break;
    case ast::Binary::MULTIPLY: output_ << "*"; break;
    case ast::Binary::SUBTRACT: output_ << "-"; break;
  }
  output_ << " ";
  Visit(binary.right);
  output_ << ")";
}

void Expression::Visit(const ast::FunctionCall& call) {
  output_ << call.function.name << "(";
  bool first = true;
  for (const auto& argument : call.arguments) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Visit(argument);
  }
  output_ << ")";
}

void Expression::Visit(const ast::LogicalNot& op) {
  output_ << "!";
  Visit(op.argument);
}

void Statement::Visit(const ast::DefineVariable& definition) {
  output_ << indent_by{indent_} << "int " << definition.name << " = ";
  Expression codegen{output_};
  codegen.Visit(definition.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::Assign& assignment) {
  output_ << indent_by{indent_} << assignment.variable << " = ";
  Expression codegen{output_};
  codegen.Visit(assignment.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::DoFunction& do_function) {
  output_ << indent_by{indent_};
  Expression codegen{output_};
  codegen.Visit(do_function.function_call);
  output_ << ";\n";
}

void Statement::Visit(const ast::If& if_statement) {
  output_ << indent_by{indent_} << "if (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(if_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(if_statement.if_true);
  output_ << indent_by{indent_} << "} else {\n";
  codegen.Visit(if_statement.if_false);
  output_ << indent_by{indent_} << "}\n";
}

void Statement::Visit(const ast::While& while_statement) {
  output_ << indent_by{indent_} << "while (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(while_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(while_statement.body);
  output_ << indent_by{indent_} << "}\n";
}

void Statement::Visit(const ast::ReturnVoid&) {
  output_ << indent_by{indent_} << "return;\n";
}

void Statement::Visit(const ast::Return& return_statement) {
  output_ << indent_by{indent_} << "return ";
  Expression codegen{output_};
  codegen.Visit(return_statement.value);
  output_ << ";\n";
}

void Statement::Visit(const std::vector<ast::Statement>& statements) {
  for (const auto& statement : statements) Visit(statement);
}

TopLevel::TopLevel(std::ostream& output)
    : output_(output) {
  output_ << kPrelude;
}

void TopLevel::Visit(const ast::DefineFunction& definition) {
  output_ << "int " << definition.name << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    output_ << "int " << parameter;
  }
  output_ << ") {\n";
  Statement codegen{output_, 2};
  codegen.Visit(definition.body);
  output_ << "}\n";
}

void TopLevel::Visit(const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      output_ << "\n";
    }
    Visit(definition);
  }
}

}  // namespace target::c
