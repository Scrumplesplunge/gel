#include "target-c.h"

#include "util.h"

#include <algorithm>
#include <iterator>

namespace target::c {
namespace {

constexpr char kPrelude[] = R"(
// Generated by the gel compiler.
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

void print(int_least64_t number) { printf("%d\n", number); }

// Start of user code.
)";

}  // namespace

void Type::Visit(const ast::Void&) {
  output_ << "void";
}

void Type::Visit(const ast::Primitive& primitive) {
  switch (primitive) {
    case ast::Primitive::BOOLEAN: output_ << "bool"; break;
    case ast::Primitive::INTEGER: output_ << "int_least64_t"; break;
  }
}

void Type::Visit(const ast::Function&) {
  throw std::logic_error(
      "No function types should have to be visited when compiling.");
}

void Expression::Visit(const ast::Identifier& identifier) {
  output_ << identifier.name;
}

void Expression::Visit(const ast::Integer& integer) {
  output_ << integer.value;
}

void Expression::Visit(const ast::Binary& binary) {
  output_ << "(";
  Visit(binary.left);
  output_ << " ";
  switch (binary.operation) {
    case ast::Binary::ADD: output_ << "+"; break;
    case ast::Binary::COMPARE_EQ: output_ << "=="; break;
    case ast::Binary::COMPARE_GE: output_ << ">="; break;
    case ast::Binary::COMPARE_GT: output_ << ">"; break;
    case ast::Binary::COMPARE_LE: output_ << "<="; break;
    case ast::Binary::COMPARE_LT: output_ << "<"; break;
    case ast::Binary::COMPARE_NE: output_ << "!="; break;
    case ast::Binary::DIVIDE: output_ << "/"; break;
    case ast::Binary::LOGICAL_AND: output_ << "&&"; break;
    case ast::Binary::LOGICAL_OR: output_ << "||"; break;
    case ast::Binary::MULTIPLY: output_ << "*"; break;
    case ast::Binary::SUBTRACT: output_ << "-"; break;
  }
  output_ << " ";
  Visit(binary.right);
  output_ << ")";
}

void Expression::Visit(const ast::FunctionCall& call) {
  output_ << call.function.name << "(";
  bool first = true;
  for (const auto& argument : call.arguments) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Visit(argument);
  }
  output_ << ")";
}

void Expression::Visit(const ast::LogicalNot& op) {
  output_ << "!";
  Visit(op.argument);
}

void Statement::Visit(const ast::DefineVariable& definition) {
  output_ << util::Spaces{indent_};
  Type type_codegen{output_};
  definition.variable.type.value().Visit(type_codegen);
  output_ << " " << definition.variable.name << " = ";
  Expression codegen{output_};
  codegen.Visit(definition.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::Assign& assignment) {
  output_ << util::Spaces{indent_} << assignment.variable.name << " = ";
  Expression codegen{output_};
  codegen.Visit(assignment.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::DoFunction& do_function) {
  output_ << util::Spaces{indent_};
  Expression codegen{output_};
  codegen.Visit(do_function.function_call);
  output_ << ";\n";
}

void Statement::Visit(const ast::If& if_statement) {
  output_ << util::Spaces{indent_} << "if (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(if_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(if_statement.if_true);
  output_ << util::Spaces{indent_} << "} else {\n";
  codegen.Visit(if_statement.if_false);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::While& while_statement) {
  output_ << util::Spaces{indent_} << "while (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(while_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(while_statement.body);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::ReturnVoid&) {
  output_ << util::Spaces{indent_} << "return;\n";
}

void Statement::Visit(const ast::Return& return_statement) {
  output_ << util::Spaces{indent_} << "return ";
  Expression codegen{output_};
  codegen.Visit(return_statement.value);
  output_ << ";\n";
}

void Statement::Visit(const std::vector<ast::Statement>& statements) {
  for (const auto& statement : statements) Visit(statement);
}

TopLevel::TopLevel(std::ostream& output)
    : output_(output) {
  output_ << kPrelude;
}

void TopLevel::Visit(const ast::DefineFunction& definition) {
  Type return_type_codegen{output_};
  const ast::Function* type =
      ast::GetFunctionType(definition.function.type.value());
  type->return_type.Visit(return_type_codegen);
  output_ << " " << definition.function.name << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Type parameter_codegen{output_};
    parameter.type.value().Visit(parameter_codegen);
    output_ << " " << parameter.name;
  }
  output_ << ") {\n";
  Statement codegen{output_, 2};
  codegen.Visit(definition.body);
  output_ << "}\n";
}

void TopLevel::Visit(const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      output_ << "\n";
    }
    Visit(definition);
  }
}

}  // namespace target::c
