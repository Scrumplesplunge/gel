#include "target-c.h"

#include "util.h"

#include <algorithm>
#include <iterator>

namespace target::c {
namespace {

constexpr char kHeader[] = R"(
// Generated by the gel compiler.
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

void gel_print(int_least64_t number) { printf("%d\n", number); }

// Start of user code.
)";

constexpr char kFooter[] = R"(
// End of user code.

int main() { return gel_main(); }
)";

void CompileExpression(const ast::Identifier&, std::ostream*);
void CompileExpression(const ast::Boolean&, std::ostream*);
void CompileExpression(const ast::Integer&, std::ostream*);
void CompileExpression(const ast::Binary&, std::ostream*);
void CompileExpression(const ast::FunctionCall&, std::ostream*);
void CompileExpression(const ast::LogicalNot&, std::ostream*);
void CompileExpression(const ast::Expression&, std::ostream*);

class Statement : public ast::StatementVisitor {
 public:
  Statement(std::ostream& output, int indent)
      : output_(output), indent_(indent) {}

  using StatementVisitor::Visit;
  void Visit(const ast::DefineVariable&) override;
  void Visit(const ast::Assign&) override;
  void Visit(const ast::DoFunction&) override;
  void Visit(const ast::If&) override;
  void Visit(const ast::While&) override;
  void Visit(const ast::ReturnVoid&) override;
  void Visit(const ast::Return&) override;
  void Visit(const std::vector<ast::Statement>& statements);

 private:
  std::ostream& output_;
  int indent_;
};

class TopLevel : public ast::TopLevelVisitor {
 public:
  TopLevel(std::ostream& output);

  using TopLevelVisitor::Visit;
  void Visit(const ast::DefineFunction&) override;
  void Visit(const std::vector<ast::DefineFunction>&) override;

 private:
  std::ostream& output_;
};

void PrintType(const ast::Type& type, std::ostream* output) {
  type.visit([&](const auto& node) {
    using value_type = std::decay_t<decltype(node)>;
    if constexpr (std::is_same_v<value_type, ast::Void>) {
      *output << "void";
    } else if constexpr (std::is_same_v<value_type, ast::Primitive>) {
      switch (node) {
        case ast::Primitive::BOOLEAN:
          *output << "bool";
          break;
        case ast::Primitive::INTEGER:
          *output << "int_least64_t";
          break;
      }
    } else if constexpr (std::is_same_v<value_type, ast::Function>) {
      throw std::logic_error(
          "No function types should have to be visited when compiling.");
    }
  });
}

void CompileExpression(const ast::Identifier& identifier,
                       std::ostream* output) {
  *output << "gel_" << identifier.name;
}

void CompileExpression(const ast::Boolean& boolean, std::ostream* output) {
  *output << (boolean.value ? "true" : "false");
}

void CompileExpression(const ast::Integer& integer, std::ostream* output) {
  *output << integer.value;
}

void CompileExpression(const ast::Binary& binary, std::ostream* output) {
  *output << "(";
  CompileExpression(binary.left, output);
  *output << " ";
  switch (binary.operation) {
    case ast::Binary::ADD:
      *output << "+";
      break;
    case ast::Binary::COMPARE_EQ:
      *output << "==";
      break;
    case ast::Binary::COMPARE_GE:
      *output << ">=";
      break;
    case ast::Binary::COMPARE_GT:
      *output << ">";
      break;
    case ast::Binary::COMPARE_LE:
      *output << "<=";
      break;
    case ast::Binary::COMPARE_LT:
      *output << "<";
      break;
    case ast::Binary::COMPARE_NE:
      *output << "!=";
      break;
    case ast::Binary::DIVIDE:
      *output << "/";
      break;
    case ast::Binary::LOGICAL_AND:
      *output << "&&";
      break;
    case ast::Binary::LOGICAL_OR:
      *output << "||";
      break;
    case ast::Binary::MULTIPLY:
      *output << "*";
      break;
    case ast::Binary::SUBTRACT:
      *output << "-";
      break;
  }
  *output << " ";
  CompileExpression(binary.right, output);
  *output << ")";
}

void CompileExpression(const ast::FunctionCall& call, std::ostream* output) {
  CompileExpression(call.function, output);
  *output << "(";
  bool first = true;
  for (const auto& argument : call.arguments) {
    if (first) {
      first = false;
    } else {
      *output << ", ";
    }
    CompileExpression(argument, output);
  }
  *output << ")";
}

void CompileExpression(const ast::LogicalNot& op, std::ostream* output) {
  *output << "!";
  CompileExpression(op.argument, output);
}

void CompileExpression(const ast::Expression& expression,
                       std::ostream* output) {
  expression.visit([&](const auto& node) { CompileExpression(node, output); });
}

void Statement::Visit(const ast::DefineVariable& definition) {
  output_ << util::Spaces{indent_};
  PrintType(definition.variable.type.value(), &output_);
  output_ << " ";
  CompileExpression(definition.variable, &output_);
  output_ << " = ";
  CompileExpression(definition.value, &output_);
  output_ << ";\n";
}

void Statement::Visit(const ast::Assign& assignment) {
  output_ << util::Spaces{indent_};
  CompileExpression(assignment.variable, &output_);
  output_ << " = ";
  CompileExpression(assignment.value, &output_);
  output_ << ";\n";
}

void Statement::Visit(const ast::DoFunction& do_function) {
  output_ << util::Spaces{indent_};
  CompileExpression(do_function.function_call, &output_);
  output_ << ";\n";
}

void Statement::Visit(const ast::If& if_statement) {
  output_ << util::Spaces{indent_} << "if (";
  CompileExpression(if_statement.condition, &output_);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(if_statement.if_true);
  output_ << util::Spaces{indent_} << "} else {\n";
  codegen.Visit(if_statement.if_false);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::While& while_statement) {
  output_ << util::Spaces{indent_} << "while (";
  CompileExpression(while_statement.condition, &output_);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(while_statement.body);
  output_ << util::Spaces{indent_} << "}\n";
}

void Statement::Visit(const ast::ReturnVoid&) {
  output_ << util::Spaces{indent_} << "return;\n";
}

void Statement::Visit(const ast::Return& return_statement) {
  output_ << util::Spaces{indent_} << "return ";
  CompileExpression(return_statement.value, &output_);
  output_ << ";\n";
}

void Statement::Visit(const std::vector<ast::Statement>& statements) {
  for (const auto& statement : statements) Visit(statement);
}

TopLevel::TopLevel(std::ostream& output) : output_(output) {}

void TopLevel::Visit(const ast::DefineFunction& definition) {
  const ast::Function* type =
      definition.function.type.value().get_if<ast::Function>();
  PrintType(type->return_type, &output_);
  output_ << " ";
  CompileExpression(definition.function, &output_);
  output_ << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    PrintType(parameter.type.value(), &output_);
    output_ << " ";
    CompileExpression(parameter, &output_);
  }
  output_ << ") {\n";
  Statement codegen{output_, 2};
  codegen.Visit(definition.body);
  output_ << "}\n";
}

void TopLevel::Visit(const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      output_ << "\n";
    }
    Visit(definition);
  }
}

}  // namespace

void Compile(const ast::TopLevel& top_level, std::ostream* output) {
  *output << kHeader;
  TopLevel codegen{*output};
  top_level.Visit(codegen);
  *output << kFooter;
}

}  // namespace target::c
