#include "target-c.h"

#include <algorithm>
#include <iterator>

namespace target::c {
namespace {

struct indent_by { int amount; };

std::ostream& operator<<(std::ostream& output, indent_by indent) {
  std::fill_n(std::ostream_iterator<char>{output}, indent.amount, ' ');
  return output;
}

constexpr char kPrelude[] = R"(
// Generated by the gel compiler.
#include <stdio.h>

void print(int number) { printf("%d\n", number); }

// Start of user code.
)";

}  // namespace

void Expression::Visit(const ast::Identifier& identifier) {
  output_ << identifier.name;
}

void Expression::Visit(const ast::Integer& integer) {
  output_ << integer.value;
}

void Expression::Visit(const ast::Add& add) {
  VisitBinary("+", add.left, add.right);
}

void Expression::Visit(const ast::Subtract& subtract) {
  VisitBinary("-", subtract.left, subtract.right);
}

void Expression::Visit(const ast::Multiply& multiply) {
  VisitBinary("*", multiply.left, multiply.right);
}

void Expression::Visit(const ast::Divide& divide) {
  VisitBinary("/", divide.left, divide.right);
}

void Expression::Visit(const ast::FunctionCall& call) {
  output_ << call.function.name << "(";
  bool first = true;
  for (const auto& argument : call.arguments) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    Visit(argument);
  }
  output_ << ")";
}

void Expression::Visit(const ast::CompareEq& compare) {
  VisitBinary("==", compare.left, compare.right);
}

void Expression::Visit(const ast::CompareNe& compare) {
  VisitBinary("!=", compare.left, compare.right);
}

void Expression::Visit(const ast::CompareLe& compare) {
  VisitBinary("<=", compare.left, compare.right);
}

void Expression::Visit(const ast::CompareLt& compare) {
  VisitBinary("<", compare.left, compare.right);
}

void Expression::Visit(const ast::CompareGe& compare) {
  VisitBinary(">=", compare.left, compare.right);
}

void Expression::Visit(const ast::CompareGt& compare) {
  VisitBinary(">", compare.left, compare.right);
}

void Expression::Visit(const ast::LogicalNot& op) {
  output_ << "!";
  Visit(op.argument);
}

void Expression::Visit(const ast::LogicalAnd& op) {
  VisitBinary("&&", op.left, op.right);
}

void Expression::Visit(const ast::LogicalOr& op) {
  VisitBinary("||", op.left, op.right);
}

void Expression::VisitBinary(std::string_view op, const ast::Expression& left,
                             const ast::Expression& right) {
  output_ << "(";
  Visit(left);
  output_ << " " << op << " ";
  Visit(right);
  output_ << ")";
}

void Statement::Visit(const ast::DefineVariable& definition) {
  output_ << indent_by{indent_} << "int " << definition.name << " = ";
  Expression codegen{output_};
  codegen.Visit(definition.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::Assign& assignment) {
  output_ << indent_by{indent_} << assignment.variable << " = ";
  Expression codegen{output_};
  codegen.Visit(assignment.value);
  output_ << ";\n";
}

void Statement::Visit(const ast::DoFunction& do_function) {
  output_ << indent_by{indent_};
  Expression codegen{output_};
  codegen.Visit(do_function.function_call);
  output_ << ";\n";
}

void Statement::Visit(const ast::If& if_statement) {
  output_ << indent_by{indent_} << "if (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(if_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(if_statement.if_true);
  output_ << indent_by{indent_} << "} else {\n";
  codegen.Visit(if_statement.if_false);
  output_ << indent_by{indent_} << "}\n";
}

void Statement::Visit(const ast::While& while_statement) {
  output_ << indent_by{indent_} << "while (";
  Expression condition_codegen{output_};
  condition_codegen.Visit(while_statement.condition);
  output_ << ") {\n";
  Statement codegen{output_, indent_ + 2};
  codegen.Visit(while_statement.body);
  output_ << indent_by{indent_} << "}\n";
}

void Statement::Visit(const ast::ReturnVoid&) {
  output_ << indent_by{indent_} << "return;\n";
}

void Statement::Visit(const ast::Return& return_statement) {
  output_ << indent_by{indent_} << "return ";
  Expression codegen{output_};
  codegen.Visit(return_statement.value);
  output_ << ";\n";
}

void Statement::Visit(const std::vector<ast::Statement>& statements) {
  for (const auto& statement : statements) Visit(statement);
}

TopLevel::TopLevel(std::ostream& output)
    : output_(output) {
  output_ << kPrelude;
}

void TopLevel::Visit(const ast::DefineFunction& definition) {
  output_ << "int " << definition.name << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      output_ << ", ";
    }
    output_ << "int " << parameter;
  }
  output_ << ") {\n";
  Statement codegen{output_, 2};
  codegen.Visit(definition.body);
  output_ << "}\n";
}

void TopLevel::Visit(const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      output_ << "\n";
    }
    Visit(definition);
  }
}

}  // namespace target::c
