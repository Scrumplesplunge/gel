#include "target-c.h"

#include "types.h"
#include "util.h"

#include <algorithm>
#include <iterator>
#include <map>

namespace target::c {
namespace {

constexpr char kHeader[] = R"(
// Generated by the gel compiler.
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct gel_void {} gel_void;
typedef bool gel_boolean;
typedef int_least64_t gel_integer;

gel_void gel_print(gel_integer number) {
  printf("%lld\n", (long long) number);
}

// Start of user code.
)";

constexpr char kFooter[] = R"(
// End of user code.

int main() { return gel_main(); }
)";

class Compiler {
 public:
  Compiler(std::ostream* output) : output_(output) {}

  // Emit code to declare the given type.
  void DeclareType(const types::Void&);
  void DeclareType(const types::Function&);
  void DeclareType(const types::Primitive&);
  void DeclareType(const types::Array&);
  void DeclareAnyType(const types::Type&);

  // Emit an assignment of the given expression to the given output variable.
  // The variable is not declared as part of this, so it should have already
  // been declared. The current line and any additional lines should be indented
  // by the given indent amount. The output should be terminated with a newline.
  void CompileExpression(std::string_view output, const ast::Identifier&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::Boolean&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::Integer&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::ArrayLiteral&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::Arithmetic&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::Compare&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::Logical&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::FunctionCall&,
                         int indent);
  void CompileExpression(std::string_view output, const ast::LogicalNot&,
                         int indent);
  void CompileAnyExpression(std::string_view output, const ast::Expression&,
                            int indent);

  // Emit code to execute the given statement. The current line and any
  // additional lines should be indented by the given indent amount. The output
  // should be terminated with a newline.
  void CompileStatement(const ast::DefineVariable&, int indent);
  void CompileStatement(const ast::Assign&, int indent);
  void CompileStatement(const ast::DoFunction&, int indent);
  void CompileStatement(const ast::If&, int indent);
  void CompileStatement(const ast::While&, int indent);
  void CompileStatement(const ast::ReturnVoid&, int indent);
  void CompileStatement(const ast::Return&, int indent);
  void CompileStatement(const std::vector<ast::Statement>&, int indent);
  void CompileAnyStatement(const ast::Statement&, int indent);

  // Emit code to declare the given constructs.
  void CompileTopLevel(const ast::DefineFunction&);
  void CompileTopLevel(const std::vector<ast::DefineFunction>&);
  void CompileAnyTopLevel(const ast::TopLevel&);

 private:
  // Generate a new unique identifier.
  std::string NextIdentifier();

  std::ostream* output_;
  std::uint64_t next_id_ = 0;
  std::map<types::Type, std::string> type_names_ = {
    {types::Void{}, "gel_void"},
    {types::Primitive::BOOLEAN, "gel_boolean"},
    {types::Primitive::INTEGER, "gel_integer"},
  };
};

void Compiler::DeclareType(const types::Void&) {
  *output_ << "// <nothing to declare>\n";
}

void Compiler::DeclareType(const types::Function&) {
  *output_ << "// <nothing to declare>\n";
}

void Compiler::DeclareType(const types::Primitive&) {
  *output_ << "// <nothing to declare>\n";
}

void Compiler::DeclareType(const types::Array& array) {
  auto name = NextIdentifier();
  const auto& element_name = type_names_.at(array.element_type);
  *output_ << "typedef struct " << name << " {\n"
           << "  " << element_name << "* data;\n"
           << "  " << type_names_.at(types::Primitive::INTEGER) << " size;\n"
           << "} " << name << ";\n";
  type_names_.emplace(array, name);
}

void Compiler::DeclareAnyType(const types::Type& type) {
  *output_ << "// " << type << "\n";
  type.visit([this](auto x) { DeclareType(x); });
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Identifier& identifier,
                                 int indent) {
  *output_ << util::Spaces{indent} << variable << " = gel_" << identifier.name
           << ";\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Boolean& boolean, int indent) {
  *output_ << util::Spaces{indent} << variable << " = "
           << (boolean.value ? "true" : "false") << ";\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Integer& integer, int indent) {
  *output_ << util::Spaces{indent} << variable << " = " << integer.value
           << ";\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::ArrayLiteral& array,
                                 int indent) {
  const types::Type& element_type =
      array.type->get_if<types::Array>()->element_type;
  const auto& element_type_name = type_names_.at(element_type);
  auto temp = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << element_type_name << "* " << temp
           << " = malloc(" << array.parts.size() << " * sizeof("
           << element_type_name << "));\n";
  for (std::size_t i = 0, n = array.parts.size(); i < n; i++) {
    CompileAnyExpression(temp + "[" + std::to_string(i) + "]", array.parts[i],
                         indent + 2);
  }
  const auto& array_type_name = type_names_.at(*array.type);
  *output_ << util::Spaces{indent + 2} << variable << " = (struct "
           << array_type_name << ") {\n" << util::Spaces{indent + 4}
           << ".data = " << temp << ",\n" << util::Spaces{indent + 4}
           << ".size = " << array.parts.size() << ",\n"
           << util::Spaces{indent + 2} << "};\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Arithmetic& binary, int indent) {
  const auto& type_name = type_names_.at(*binary.type);
  auto left = NextIdentifier(), right = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << type_name << " " << left << ", "
           << right << ";\n";
  CompileAnyExpression(left, binary.left, indent + 2);
  CompileAnyExpression(right, binary.right, indent + 2);
  *output_ << util::Spaces{indent + 2} << variable << " = " << left << " ";
  switch (binary.operation) {
    case ast::Arithmetic::ADD:
      *output_ << "+";
      break;
    case ast::Arithmetic::DIVIDE:
      *output_ << "/";
      break;
    case ast::Arithmetic::MULTIPLY:
      *output_ << "*";
      break;
    case ast::Arithmetic::SUBTRACT:
      *output_ << "-";
      break;
  }
  *output_ << " " << right << ";\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Compare& binary, int indent) {
  const auto& type_name = type_names_.at(*GetMeta(binary.left).type);
  auto left = NextIdentifier(), right = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << type_name << " " << left << ", "
           << right << ";\n";
  CompileAnyExpression(left, binary.left, indent + 2);
  CompileAnyExpression(right, binary.right, indent + 2);
  *output_ << util::Spaces{indent + 2} << variable << " = " << left << " ";
  switch (binary.operation) {
    case ast::Compare::EQUAL:
      *output_ << "==";
      break;
    case ast::Compare::GREATER_OR_EQUAL:
      *output_ << ">=";
      break;
    case ast::Compare::GREATER_THAN:
      *output_ << ">";
      break;
    case ast::Compare::LESS_OR_EQUAL:
      *output_ << "<=";
      break;
    case ast::Compare::LESS_THAN:
      *output_ << "<";
      break;
    case ast::Compare::NOT_EQUAL:
      *output_ << "!=";
      break;
  }
  *output_ << " " << right << ";\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::Logical& binary, int indent) {
  auto end = NextIdentifier();
  CompileAnyExpression(variable, binary.left, indent);
  // Generate the short-circuit path.
  *output_ << util::Spaces{indent} << "if (";
  switch (binary.operation) {
    case ast::Logical::AND:
      *output_ << "!" << variable;
      break;
    case ast::Logical::OR:
      *output_ << variable;
      break;
  }
  *output_ << ") goto " << end << ";\n";
  CompileAnyExpression(variable, binary.right, indent);
  *output_ << end << ":\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::FunctionCall& call,
                                 int indent) {
  *output_ << util::Spaces{indent} << "{\n";
  // Generate each argument, left-to-right, and store them in variables.
  auto n = call.arguments.size();
  std::vector<std::string> arguments;
  arguments.reserve(n);
  for (std::size_t i = 0; i < n; i++) {
    arguments.push_back(NextIdentifier());
    const auto& type_name = type_names_.at(*GetMeta(call.arguments[i]).type);
    *output_ << util::Spaces{indent + 2} << type_name << " "
             << arguments.back() << ";\n";
    CompileAnyExpression(arguments.back(), call.arguments[i], indent + 2);
  }

  // Call the function with all of the arguments.
  *output_ << util::Spaces{indent} << variable << " = gel_"
           << call.function.name << "(";
  bool first = true;
  for (const auto& argument : arguments) {
    if (first) {
      first = false;
    } else {
      *output_ << ", ";
    }
    *output_ << argument;
  }
  *output_ << ");\n" << util::Spaces{indent} << "}\n";
}

void Compiler::CompileExpression(std::string_view variable,
                                 const ast::LogicalNot& op, int indent) {
  CompileAnyExpression(variable, op.argument, indent);
  *output_ << util::Spaces{indent} << variable << " = !" << variable << ";\n";
}

void Compiler::CompileAnyExpression(std::string_view variable,
                                    const ast::Expression& expression,
                                    int indent) {
  expression.visit(
      [&](const auto& node) { CompileExpression(variable, node, indent); });
}

void Compiler::CompileStatement(const ast::DefineVariable& definition,
                                int indent) {
  const auto& type_name = type_names_.at(*definition.variable.type);
  *output_ << util::Spaces{indent} << type_name << " gel_"
           << definition.variable.name << ";\n";
  CompileAnyExpression("gel_" + definition.variable.name, definition.value,
                       indent);
}

void Compiler::CompileStatement(const ast::Assign& assignment, int indent) {
  CompileAnyExpression("gel_" + assignment.variable.name, assignment.value,
                       indent);
}

void Compiler::CompileStatement(const ast::DoFunction& do_function,
                                int indent) {
  auto ignored_result = NextIdentifier();
  const auto& result_type_name =
      type_names_.at(*do_function.function_call.type);
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << result_type_name << " "
           << ignored_result << ";\n";
  CompileExpression(ignored_result, do_function.function_call, indent + 2);
  *output_ << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const ast::If& if_statement, int indent) {
  auto condition = NextIdentifier();
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << "bool " << condition << ";\n";
  CompileAnyExpression(condition, if_statement.condition, indent + 2);
  *output_ << util::Spaces{indent + 2} << "if (" << condition << ") {\n";
  CompileStatement(if_statement.if_true, indent + 4);
  *output_ << util::Spaces{indent + 2} << "} else {\n";
  CompileStatement(if_statement.if_false, indent + 4);
  *output_ << util::Spaces{indent + 2} << "}\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const ast::While& while_statement, int indent) {
  auto condition = NextIdentifier();
  *output_ << util::Spaces{indent} << "while (true) {\n"
           << util::Spaces{indent + 2} << "bool " << condition << ";\n";
  CompileAnyExpression(condition, while_statement.condition, indent + 2);
  *output_ << util::Spaces{indent + 2} << "if (!" << condition << ") break;\n";
  CompileStatement(while_statement.body, indent + 2);
  *output_ << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const ast::ReturnVoid&, int indent) {
  *output_ << util::Spaces{indent} << "return;\n";
}

void Compiler::CompileStatement(const ast::Return& return_statement,
                                int indent) {
  auto result = NextIdentifier();
  const auto& result_type_name =
      type_names_.at(*GetMeta(return_statement.value).type);
  *output_ << util::Spaces{indent} << "{\n"
           << util::Spaces{indent + 2} << result_type_name << " " << result
           << ";\n";
  CompileAnyExpression(result, return_statement.value, indent + 2);
  *output_ << util::Spaces{indent + 2} << "return " << result << ";\n"
           << util::Spaces{indent} << "}\n";
}

void Compiler::CompileStatement(const std::vector<ast::Statement>& statements,
                                int indent) {
  for (const auto& statement : statements)
    CompileAnyStatement(statement, indent);
}

void Compiler::CompileAnyStatement(const ast::Statement& statement,
                                   int indent) {
  statement.visit([&](const auto& x) { CompileStatement(x, indent); });
}

void Compiler::CompileTopLevel(const ast::DefineFunction& definition) {
  const types::Function* type =
      definition.function.type.value().get_if<types::Function>();
  const auto& return_type_name = type_names_.at(type->return_type);
  *output_ << return_type_name << " gel_" << definition.function.name << "(";
  bool first = true;
  for (const auto& parameter : definition.parameters) {
    if (first) {
      first = false;
    } else {
      *output_ << ", ";
    }
    const auto& parameter_type_name = type_names_.at(*parameter.type);
    *output_ << parameter_type_name << " gel_" << parameter.name;
  }
  *output_ << ") {\n";
  CompileStatement(definition.body, 2);
  *output_ << "}\n";
}

void Compiler::CompileTopLevel(
    const std::vector<ast::DefineFunction>& definitions) {
  bool first = true;
  for (const auto& definition : definitions) {
    if (first) {
      first = false;
    } else {
      *output_ << "\n";
    }
    CompileTopLevel(definition);
  }
}

void Compiler::CompileAnyTopLevel(const ast::TopLevel& top_level) {
  top_level.visit([&](const auto& x) { CompileTopLevel(x); });
}

std::string Compiler::NextIdentifier() {
  auto id = next_id_++;
  return "gel" + std::to_string(id);
}

}  // namespace

void Compile(const analysis::GlobalContext& context,
             const ast::TopLevel& top_level, std::ostream* output) {
  Compiler compiler{output};
  *output << kHeader;
  for (const auto& type : context.types) compiler.DeclareAnyType(type);
  compiler.CompileAnyTopLevel(top_level);
  *output << kFooter;
}

}  // namespace target::c
